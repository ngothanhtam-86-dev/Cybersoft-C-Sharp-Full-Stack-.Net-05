{
	"Console.WriteLine": {
		"prefix": "cwl",
		"body": [
			"Console.WriteLine($@\"${1}\");"
		],
		"description": "Console.WriteLine with interpolated string"
	},
	"Console.Write": {
		"prefix": "cw",
		"body": [
			"Console.Write($@\"${1}\");"
		],
		"description": "Console.Write with interpolated string"
	},
	"Console.ReadLine": {
		"prefix": "cr",
		"body": [
			"Console.ReadLine();"
		],
		"description": "Console.ReadLine"
	},
	"Convert type": {
		"prefix": "cv",
		"body": [
			"${1} = Convert.${2}(Console.ReadLine());"
		],
		"description": "Đọc input và convert to Int32"
	},
	"Function with parameters and return type": {
		"prefix": "funcINT",
		"body": [
			"public int ${1:function_name}(int ${2:a}, int ${3:b})",
			"{",
			"int abc = 0;",
			"return ${4:abc};",
			"}"
		],
		"description": "Hàm trả về một giá trị kiểu int và có tham số"
	},
	"Function void": {
		"prefix": "funcVOID",
		"body": [
			"public void ${1:function_name}()",
			"{",
			"Console.WriteLine(Hello, world!);",
			"}"
		],
		"description": "Hàm không trả về giá trị (void) và không có tham số"
	},
	"Function modifier": {
		"prefix": "func",
		"body": [
			"${1: access_modifier} ${2: return_func_type} ${3: function_name} (${4: parameters})",
			"{",
			"// Function body",
			"}"
		],
		"description": "access_modifier: Mức truy cập của hàm (ví dụ: public, private, protected, hoặc không ghi gì là mặc định private)."
	},
	"Public class": {
		"prefix": "classPublic",
		"body": [
			"public class ${1:ten_class}",
			"{",
			"public int ${2:ten_bien} { get; set; }",
			"}"
		],
		"description": "public: Thành viên của class được truy cập từ bất kỳ đâu trong chương trình."
	},
	"Protected property": {
		"prefix": "classProtect",
		"body": [
			"public class ${1:ten_class}",
			"{",
			"protected int ${2:ten_bien_protect} { get; set; }",
			"}",
			"//cách truy cập kế thừa",
			"public class ${3:ten_class} : ${4:ke_thua_tu_class?}",
			"{",
			"protected int ${2:ten_bien_protect} { get; set; }",
			"}"
		],
		"description": "protected: Thành viên chỉ có thể được truy cập từ bên trong class hoặc các class kế thừa (subclasses)."
	},
	"Protected internal": {
		"prefix": "classProtectInternal",
		"body": [
			"public class ${1:ten_class}",
			"{",
			"protected internal int ${2:ten_bien_protect_internal} { get; set; }",
			"//Function body",
			"}"
		],
		"description": "Protected internal: Thành viên có thể được truy cập từ các lớp kế thừa hoặc từ các lớp trong cùng một assembly (project)."
	},
	"Entity Service Pattern": {
		"prefix": "service",
		"body": [
			"public interface I${1:Entity}Service",
			"{",
			"    Task<IEnumerable<$1>> GetAllAsync();",
			"    Task<$1?> GetByIdAsync(int id);",
			"    Task<$1?> SingleOrDefaultAsync(Expression<Func<$1, bool>> predicate);",
			"    Task<IEnumerable<$1>> WhereAsync(Expression<Func<$1, bool>> predicate);",
			"    Task AddAsync($1 entity);",
			"    Task UpdateAsync($1 entity);",
			"    Task DeleteAsync(int id);",
			"}",
			"",
			"public class ${1:Entity}Service : I$1Service",
			"{",
			"    private readonly IRepository<$1> _repository;",
			"",
			"    public $1Service(IRepository<$1> repository)",
			"    {",
			"        _repository = repository;",
			"    }",
			"",
			"    public async Task<IEnumerable<$1>> GetAllAsync() => await _repository.GetAllAsync();",
			"",
			"    public async Task<$1?> GetByIdAsync(int id) => await _repository.GetByIdAsync(id);",
			"",
			"    public async Task<$1?> SingleOrDefaultAsync(Expression<Func<$1, bool>> predicate) => await _repository.SingleOrDefaultAsync(predicate);",
			"",
			"    public async Task<IEnumerable<$1>> WhereAsync(Expression<Func<$1, bool>> predicate) => await _repository.WhereAsync(predicate);",
			"",
			"    public async Task AddAsync($1 entity) => await _repository.AddAsync(entity);",
			"",
			"    public async Task UpdateAsync($1 entity) => _repository.Update(entity);",
			"",
			"    public async Task DeleteAsync(int id) => await _repository.DeleteAsync(id);",
			"}"
		],
		"description": "Generate Service + Interface for an Entity"
	},
	"Entity Repository": {
		"prefix": "repo",
		"body": [
			"public interface I${1:Entity}Repository : IRepository<$1>",
			"{",
			"    // Add custom methods for $1 here if needed",
			"}",
			"",
			"public class ${1:Entity}Repository : Repository<$1>, I$1Repository",
			"{",
			"    public ${1:Entity}Repository(DbContext context) : base(context)",
			"    {",
			"    }",
			"}"
		],
		"description": "Generate Repository + Interface for an Entity"
	},
	"blazor-state-service": {
		"prefix": "blazor-state-service",
		"scope": "csharp",
		"body": [
			"using System.Net.Http;",
			"using System.Net.Http.Json;",
			"",
			"public class ${1:ProductStateService}(HttpClient http)",
			"{",
			"    private string _message = \"Hello\";",
			"    public string Message => _message;",
			"",
			"    public event Action? OnChange;",
			"",
			"    private void NotifyStateChanged() => OnChange?.Invoke();",
			"",
			"    public void SetMessage(string message)",
			"    {",
			"        _message = message;",
			"        NotifyStateChanged();",
			"    }",
			"",
			"    // Place your HTTP methods below",
			"}"
		],
		"description": "State service class với constructor và NotifyStateChanged"
	},
	"blazor-state-get": {
		"prefix": "blazor-state-get",
		"scope": "csharp",
		"body": [
			"public async Task<T?> GetAsync<T>(string url)",
			"{",
			"    try",
			"    {",
			"        return await http.GetFromJsonAsync<T>(url);",
			"    }",
			"    catch (Exception ex)",
			"    {",
			"        Console.WriteLine($\"GET failed: {ex.Message}\");",
			"        return default;",
			"    }",
			"}"
		],
		"description": "Http GET method với HttpClient"
	},
	"blazor-state-post": {
		"prefix": "blazor-state-post",
		"scope": "csharp",
		"body": [
			"public async Task<T?> PostAsync<T>(string url, object data, string? token = null)",
			"{",
			"    try",
			"    {",
			"        var request = new HttpRequestMessage(HttpMethod.Post, url)",
			"        {",
			"            Content = JsonContent.Create(data)",
			"        };",
			"        if (!string.IsNullOrEmpty(token))",
			"        {",
			"            request.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token);",
			"        }",
			"        var response = await http.SendAsync(request);",
			"        response.EnsureSuccessStatusCode();",
			"        return await response.Content.ReadFromJsonAsync<T>();",
			"    }",
			"    catch (Exception ex)",
			"    {",
			"        Console.WriteLine($\"POST failed: {ex.Message}\");",
			"        return default;",
			"    }",
			"}"
		],
		"description": "Http POST method với header Authorization (token)"
	},
	"blazor-state-put": {
		"prefix": "blazor-state-put",
		"scope": "csharp",
		"body": [
			"public async Task<bool> PutAsync(string url, object data)",
			"{",
			"    try",
			"    {",
			"        var response = await http.PutAsJsonAsync(url, data);",
			"        response.EnsureSuccessStatusCode();",
			"        NotifyStateChanged();",
			"        return true;",
			"    }",
			"    catch (Exception ex)",
			"    {",
			"        Console.WriteLine($\"PUT failed: {ex.Message}\");",
			"        return false;",
			"    }",
			"}"
		],
		"description": "Http PUT method có NotifyStateChanged"
	},
	"blazor-state-delete": {
		"prefix": "blazor-state-delete",
		"scope": "csharp",
		"body": [
			"public async Task<bool> DeleteAsync(string url)",
			"{",
			"    try",
			"    {",
			"        var response = await http.DeleteAsync(url);",
			"        response.EnsureSuccessStatusCode();",
			"        NotifyStateChanged();",
			"        return true;",
			"    }",
			"    catch (Exception ex)",
			"    {",
			"        Console.WriteLine($\"DELETE failed: {ex.Message}\");",
			"        return false;",
			"    }",
			"}"
		],
		"description": "Http DELETE method có NotifyStateChanged"
	},
	"blazor-state-service-full": {
		"prefix": "blazor-state-service-full",
		"scope": "csharp",
		"body": [
			"using System.Net.Http;",
			"using System.Net.Http.Json;",
			"",
			"public class ${1:ProductStateService}(HttpClient http)",
			"{",
			"    private string _message = \"Hello\";",
			"    public string Message => _message;",
			"",
			"    public event Action? OnChange;",
			"",
			"    private void NotifyStateChanged() => OnChange?.Invoke();",
			"",
			"    public void SetMessage(string message)",
			"    {",
			"        _message = message;",
			"        NotifyStateChanged();",
			"    }",
			"",
			"    // ----------- HTTP METHODS -----------",
			"",
			"    public async Task<T?> GetAsync<T>(string url)",
			"    {",
			"        try",
			"        {",
			"            return await http.GetFromJsonAsync<T>(url);",
			"        }",
			"        catch (Exception ex)",
			"        {",
			"            Console.WriteLine($\"GET failed: {ex.Message}\");",
			"            return default;",
			"        }",
			"    }",
			"",
			"    public async Task<T?> PostAsync<T>(string url, object data, string? token = null)",
			"    {",
			"        try",
			"        {",
			"            var request = new HttpRequestMessage(HttpMethod.Post, url)",
			"            {",
			"                Content = JsonContent.Create(data)",
			"            };",
			"",
			"            if (!string.IsNullOrEmpty(token))",
			"            {",
			"                request.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token);",
			"            }",
			"",
			"            var response = await http.SendAsync(request);",
			"            response.EnsureSuccessStatusCode();",
			"            return await response.Content.ReadFromJsonAsync<T>();",
			"        }",
			"        catch (Exception ex)",
			"        {",
			"            Console.WriteLine($\"POST failed: {ex.Message}\");",
			"            return default;",
			"        }",
			"    }",
			"",
			"    public async Task<bool> PutAsync(string url, object data)",
			"    {",
			"        try",
			"        {",
			"            var response = await http.PutAsJsonAsync(url, data);",
			"            response.EnsureSuccessStatusCode();",
			"            NotifyStateChanged();",
			"            return true;",
			"        }",
			"        catch (Exception ex)",
			"        {",
			"            Console.WriteLine($\"PUT failed: {ex.Message}\");",
			"            return false;",
			"        }",
			"    }",
			"",
			"    public async Task<bool> DeleteAsync(string url)",
			"    {",
			"        try",
			"        {",
			"            var response = await http.DeleteAsync(url);",
			"            response.EnsureSuccessStatusCode();",
			"            NotifyStateChanged();",
			"            return true;",
			"        }",
			"        catch (Exception ex)",
			"        {",
			"            Console.WriteLine($\"DELETE failed: {ex.Message}\");",
			"            return false;",
			"        }",
			"    }",
			"}"
		],
		"description": "State management service đầy đủ (C# 12) + HTTP + NotifyStateChanged"
	},
	"signalr-send-all": {
		"prefix": "signalr-send-all",
		"scope": "csharp",
		"body": [
			"// Gửi message đến tất cả client",
			"public async Task SendToAll(string message)",
			"{",
			"    await Clients.All.SendAsync(\"ReceiveMessage\", message);",
			"}"
		],
		"description": "SignalR: Gửi tới tất cả client"
	},
	"signalr-send-clientid": {
		"prefix": "signalr-send-clientid",
		"scope": "csharp",
		"body": [
			"// Gửi message đến 1 client cụ thể theo connectionId",
			"public async Task SendToClient(string connectionId, string message)",
			"{",
			"    await Clients.Client(connectionId).SendAsync(\"ReceiveMessage\", message);",
			"}"
		],
		"description": "SignalR: Gửi theo connectionId"
	},
	"signalr-send-group": {
		"prefix": "signalr-send-group",
		"scope": "csharp",
		"body": [
			"// Gửi message đến 1 group cụ thể",
			"public async Task SendToGroup(string groupName, string message)",
			"{",
			"    await Clients.Group(groupName).SendAsync(\"ReceiveMessage\", message);",
			"}"
		],
		"description": "SignalR: Gửi theo group"
	},
	"signalr-group-handling": {
		"prefix": "signalr-group-handling",
		"scope": "csharp",
		"body": [
			"// Tham gia group",
			"public async Task JoinGroup(string groupName)",
			"{",
			"    await Groups.AddToGroupAsync(Context.ConnectionId, groupName);",
			"}",
			"",
			"// Rời khỏi group",
			"public async Task LeaveGroup(string groupName)",
			"{",
			"    await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName);",
			"}"
		],
		"description": "SignalR: Join & Leave group theo ConnectionId"
	},
	"signalr-connected": {
		"prefix": "signalr-connected",
		"scope": "csharp",
		"body": [
			"public override async Task OnConnectedAsync()",
			"{",
			"    Console.WriteLine($\"[SignalR] Client connected: {Context.ConnectionId}\");",
			"    await base.OnConnectedAsync();",
			"}"
		],
		"description": "SignalR: OnConnectedAsync"
	},
	"signalr-disconnected": {
		"prefix": "signalr-disconnected",
		"scope": "csharp",
		"body": [
			"public override async Task OnDisconnectedAsync(Exception? exception)",
			"{",
			"    Console.WriteLine($\"[SignalR] Client disconnected: {Context.ConnectionId}\");",
			"    await base.OnDisconnectedAsync(exception);",
			"}"
		],
		"description": "SignalR: OnDisconnectedAsync"
	},
	"signalr-hub-full": {
		"prefix": "signalr-hub-full",
		"scope": "csharp",
		"body": [
			"using Microsoft.AspNetCore.SignalR;",
			"",
			"public class ${1:NotificationHub} : Hub",
			"{",
			"    public async Task SendToAll(string message)",
			"    {",
			"        await Clients.All.SendAsync(\"ReceiveMessage\", message);",
			"    }",
			"",
			"    public async Task SendToClient(string connectionId, string message)",
			"    {",
			"        await Clients.Client(connectionId).SendAsync(\"ReceiveMessage\", message);",
			"    }",
			"",
			"    public async Task SendToGroup(string groupName, string message)",
			"    {",
			"        await Clients.Group(groupName).SendAsync(\"ReceiveMessage\", message);",
			"    }",
			"",
			"    public async Task JoinGroup(string groupName)",
			"    {",
			"        await Groups.AddToGroupAsync(Context.ConnectionId, groupName);",
			"    }",
			"",
			"    public async Task LeaveGroup(string groupName)",
			"    {",
			"        await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName);",
			"    }",
			"",
			"    public override async Task OnConnectedAsync()",
			"    {",
			"        Console.WriteLine($\"[SignalR] Connected: {Context.ConnectionId}\");",
			"        await base.OnConnectedAsync();",
			"    }",
			"",
			"    public override async Task OnDisconnectedAsync(Exception? exception)",
			"    {",
			"        Console.WriteLine($\"[SignalR] Disconnected: {Context.ConnectionId}\");",
			"        await base.OnDisconnectedAsync(exception);",
			"    }",
			"}"
		],
		"description": "SignalR Hub đầy đủ: send, group, connect, disconnect"
	},
	"signalr-service": {
		"prefix": "signalr-service",
		"scope": "csharp",
		"body": [
			"using Microsoft.AspNetCore.SignalR;",
			"",
			"public class ${1:SignalRPushService}",
			"{",
			"    private readonly IHubContext<ClassHub> _hubContext;",
			"",
			"    public ${1:SignalRPushService}(IHubContext<ClassHub> hubContext)",
			"    {",
			"        _hubContext = hubContext;",
			"    }",
			"",
			"    public async Task PushToAllAsync(string message)",
			"    {",
			"        await _hubContext.Clients.All.SendAsync(\"ReceiveMessage\", message);",
			"    }",
			"",
			"    public async Task PushToClientAsync(string connectionId, string message)",
			"    {",
			"        await _hubContext.Clients.Client(connectionId).SendAsync(\"ReceiveMessage\", message);",
			"    }",
			"",
			"    public async Task PushToGroupAsync(string groupName, string message)",
			"    {",
			"        await _hubContext.Clients.Group(groupName).SendAsync(\"ReceiveMessage\", message);",
			"    }",
			"}"
		],
		"description": "SignalR push service sử dụng IHubContext<ClassHub>"
	},
	"signalr-di-service": {
		"prefix": "signalr-di-service",
		"scope": "csharp",
		"body": [
			"// Thêm vào Program.cs để cấu hình SignalR",
			"builder.Services.AddSignalR();",
			"",
			"// Map ClassHub tại endpoint",
			"app.MapHub<ClassHub>(\"/hub/notification\");"
		],
		"description": "Cấu hình SignalR trong Program.cs (AddSignalR + MapHub)"
	},
	"signalr-map-classhub": {
		"prefix": "signalr-map-classhub",
		"scope": "csharp",
		"body": [
			"app.MapHub<ClassHub>(\"/hub/notification\");"
		],
		"description": "Map ClassHub vào endpoint SignalR"
	},
	"signalr-hub-full": {
		"prefix": "signalr-hub-full",
		"scope": "csharp",
		"body": [
			"using Microsoft.AspNetCore.SignalR;",
			"",
			"public class ClassHub : Hub",
			"{",
			"    public async Task SendToAll(string message)",
			"    {",
			"        await Clients.All.SendAsync(\"ReceiveMessage\", message);",
			"    }",
			"",
			"    public async Task SendToClient(string connectionId, string message)",
			"    {",
			"        await Clients.Client(connectionId).SendAsync(\"ReceiveMessage\", message);",
			"    }",
			"",
			"    public async Task SendToGroup(string groupName, string message)",
			"    {",
			"        await Clients.Group(groupName).SendAsync(\"ReceiveMessage\", message);",
			"    }",
			"",
			"    public async Task JoinGroup(string groupName)",
			"    {",
			"        await Groups.AddToGroupAsync(Context.ConnectionId, groupName);",
			"    }",
			"",
			"    public async Task LeaveGroup(string groupName)",
			"    {",
			"        await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName);",
			"    }",
			"",
			"    public override async Task OnConnectedAsync()",
			"    {",
			"        Console.WriteLine($\"[SignalR] Connected: {Context.ConnectionId}\");",
			"        await base.OnConnectedAsync();",
			"    }",
			"",
			"    public override async Task OnDisconnectedAsync(Exception? exception)",
			"    {",
			"        Console.WriteLine($\"[SignalR] Disconnected: {Context.ConnectionId}\");",
			"        await base.OnDisconnectedAsync(exception);",
			"    }",
			"}"
		],
		"description": "SignalR Hub đầy đủ: ClassHub (send, group, connect)"
	},
	"C# Class from filename with Id and Name": {
		"prefix": "class ob",
		"body": [
			"public class ${TM_FILENAME_BASE}",
			"{",
			"    public int Id { get; set; }",
			"    public string Name { get; set; }",
			"    ",
			"    $0",
			"}"
		],
		"description": "Create a C# class with class name from filename and default properties Id, Name"
	},
	"Add DbContext with SQL Server (Custom Connection and Context Name)": {
		"prefix": "service-context",
		"body": [
			"var connectionString = builder.Configuration.GetConnectionString(\"${1:YourConnectionName}\");",
			"",
			"builder.Services.AddDbContext<${2:YourDbContextName}>(options =>",
			"    options",
			"        .UseLazyLoadingProxies(false)",
			"        .UseSqlServer(connectionString));"
		],
		"description": "Register a DbContext with a custom connection string and context name"
	},
	"Add CORS Policy - Allow All": {
		"prefix": "middleware-cors",
		"body": [
			"builder.Services.AddCors(options =>",
			"{",
			"    options.AddPolicy(\"AllowAll\",",
			"        policy => policy.AllowAnyOrigin()",
			"                          .AllowAnyHeader()",
			"                          .AllowAnyMethod());",
			"});"
		],
		"description": "Add CORS policy that allows any origin, header, and method"
	},
	"Kafka Producer Class": {
		"prefix": "kafka-producer",
		"body": [
			"using Confluent.Kafka;",
			"using Microsoft.Extensions.Logging;",
			"",
			"namespace ${1:YourNamespace}.Kafka",
			"{",
			"    public interface IKafkaProducer",
			"    {",
			"        Task ProduceAsync(string topic, Message<string, string> message);",
			"    }",
			"",
			"    public class KafkaProducer : IKafkaProducer",
			"    {",
			"        private readonly IProducer<string, string> _producer;",
			"",
			"        public KafkaProducer()",
			"        {",
			"            var config = new ProducerConfig",
			"            {",
			"                BootstrapServers = \"${2:localhost:9092}\" // Kafka server",
			"            };",
			"            _producer = new ProducerBuilder<string, string>(config).Build();",
			"        }",
			"",
			"        public Task ProduceAsync(string topic, Message<string, string> message)",
			"        {",
			"            return _producer.ProduceAsync(topic, message); // Send message",
			"        }",
			"    }",
			"}"
		],
		"description": "Create Kafka Producer class with interface"
	},
	"Kafka Consumer Class": {
		"prefix": "kafka-consumer",
		"body": [
			"using System.Text.Json;",
			"using System.Threading;",
			"using System.Threading.Tasks;",
			"using Confluent.Kafka;",
			"using Microsoft.Extensions.DependencyInjection;",
			"using Microsoft.Extensions.Hosting;",
			"",
			"namespace ${1:YourNamespace}.Kafka",
			"{",
			"    public class KafkaConsumer(IServiceScopeFactory scopeFactory) : BackgroundService",
			"    {",
			"        protected override Task ExecuteAsync(CancellationToken stoppingToken)",
			"        {",
			"            return Task.Run(() =>",
			"            {",
			"                _ = ComsumeAsync(\"${2:your-topic}\", stoppingToken);",
			"            }, stoppingToken);",
			"        }",
			"",
			"        public async Task ComsumeAsync(string topic, CancellationToken stoppingToken)",
			"        {",
			"            var config = new ConsumerConfig",
			"            {",
			"                GroupId = \"${3:your-group-id}\",",
			"                BootstrapServers = \"${4:localhost:9092}\",",
			"                AutoOffsetReset = AutoOffsetReset.Earliest",
			"            };",
			"",
			"            using var consumer = new ConsumerBuilder<string, string>(config).Build();",
			"            consumer.Subscribe(topic);",
			"",
			"            while (!stoppingToken.IsCancellationRequested)",
			"            {",
			"                var consumeResult = consumer.Consume(stoppingToken);",
			"",
			"                var messageValue = consumeResult.Message.Value;",
			"                // 👇 Change 'YourModel' to your actual model class",
			"                var data = JsonSerializer.Deserialize<${5:YourModel}>(messageValue);",
			"",
			"                // TODO: Handle the consumed data here",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Kafka Consumer class using BackgroundService"
	},
	"Add Kafka Consumer as Hosted Service": {
		"prefix": "service-consumer",
		"body": [
			"builder.Services.AddHostedService<${1:KafkaConsumer}>();"
		],
		"description": "Add Kafka consumer as a background hosted service"
	},
	"Kafka Consumer (Multi-Topic, DbContext, Basic)": {
		"prefix": "kafka-consumer-multi-topic-basic",
		"body": [
			"using System.Text.Json;",
			"using System.Threading;",
			"using Confluent.Kafka;",
			"using Microsoft.Extensions.DependencyInjection;",
			"using Microsoft.Extensions.Hosting;",
			"using ${1:YourNamespace}.Models;",
			"",
			"public class ${2:KafkaConsumer}(IServiceScopeFactory scopeFactory) : BackgroundService",
			"{",
			"    protected override Task ExecuteAsync(CancellationToken stoppingToken)",
			"    {",
			"        var topics = new[] { \"${3:topic-1}\", \"${4:topic-2}\"${5:, \"topic-3\"} };",
			"        return Task.Run(() => ComsumeAsync(topics, stoppingToken), stoppingToken);",
			"    }",
			"",
			"    public async Task ComsumeAsync(IEnumerable<string> topics, CancellationToken stoppingToken)",
			"    {",
			"        var config = new ConsumerConfig",
			"        {",
			"            GroupId = \"${6:your-group-id}\",",
			"            BootstrapServers = \"${7:localhost:9092}\",",
			"            AutoOffsetReset = AutoOffsetReset.Earliest",
			"        };",
			"",
			"        using var consumer = new ConsumerBuilder<string, string>(config).Build();",
			"        consumer.Subscribe(topics);",
			"",
			"        Console.WriteLine($\"✅ Subscribed to topics: {string.Join(\", \", topics)}\");",
			"",
			"        while (!stoppingToken.IsCancellationRequested)",
			"        {",
			"            try",
			"            {",
			"                var result = consumer.Consume(stoppingToken);",
			"                Console.WriteLine($\"📥 [${8:result.Topic}] Received message: {result.Message.Value}\");",
			"",
			"                using var scope = scopeFactory.CreateScope();",
			"                var dbContext = scope.ServiceProvider.GetRequiredService<${9:YourDbContext}>();",
			"",
			"                switch (result.Topic)",
			"                {",
			"                    case \"${3:topic-1}\":",
			"                        var model1 = JsonSerializer.Deserialize<${10:Model1}>(result.Message.Value);",
			"                        // TODO: Handle topic-1 message",
			"                        break;",
			"",
			"                    case \"${4:topic-2}\":",
			"                        var model2 = JsonSerializer.Deserialize<${11:Model2}>(result.Message.Value);",
			"                        // TODO: Handle topic-2 message",
			"                        break;",
			"",
			"                    ${12:// case \"topic-3\": ... }",
			"",
			"                    default:",
			"                        Console.WriteLine($\"❓ Unknown topic: {result.Topic}\");",
			"                        break;",
			"                }",
			"",
			"                await dbContext.SaveChangesAsync();",
			"            }",
			"            catch (Exception ex)",
			"            {",
			"                Console.WriteLine($\"❌ KafkaConsumer error: {ex.Message}\");",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Kafka consumer background service lắng nghe nhiều topic, dùng DI DbContext, xử lý logic từng topic theo switch-case"
	},
	"JWT Auth Service Class": {
		"prefix": "jwtservice",
		"body": [
			"using System;",
			"using System.Collections.Generic;",
			"using System.IdentityModel.Tokens.Jwt;",
			"using System.Security.Claims;",
			"using System.Text;",
			"using Microsoft.Extensions.Configuration;",
			"using Microsoft.IdentityModel.Tokens;",
			"",
			"public class JwtAuthService",
			"{",
			"    private readonly string _key;",
			"    private readonly string _issuer;",
			"    private readonly string _audience;",
			"",
			"    public JwtAuthService(IConfiguration Configuration)",
			"    {",
			"        _key = Configuration[\"Jwt:Key\"];",
			"        _issuer = Configuration[\"Jwt:issuer\"];",
			"        _audience = Configuration[\"Jwt:audience\"];",
			"    }",
			"",
			"    public string GenerateToken(string username, string role)",
			"    {",
			"        var key = Encoding.ASCII.GetBytes(_key);",
			"",
			"        var claims = new List<Claim>",
			"        {",
			"            new Claim(ClaimTypes.Name, username),",
			"            new Claim(ClaimTypes.Role, role),",
			"            new Claim(JwtRegisteredClaimNames.Sub, username),",
			"            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),",
			"            new Claim(JwtRegisteredClaimNames.Iat, DateTime.UtcNow.ToString(), ClaimValueTypes.DateTime)",
			"        };",
			"",
			"        var credentials = new SigningCredentials(",
			"            new SymmetricSecurityKey(key),",
			"            SecurityAlgorithms.HmacSha256Signature",
			"        );",
			"",
			"        var tokenDescriptor = new SecurityTokenDescriptor",
			"        {",
			"            Subject = new ClaimsIdentity(claims),",
			"            Expires = DateTime.UtcNow.AddHours(1),",
			"            SigningCredentials = credentials,",
			"            Issuer = _issuer,",
			"            Audience = _audience",
			"        };",
			"",
			"        var tokenHandler = new JwtSecurityTokenHandler();",
			"        var token = tokenHandler.CreateToken(tokenDescriptor);",
			"        return tokenHandler.WriteToken(token);",
			"    }",
			"}"
		],
		"description": "Tạo class JwtAuthService sinh mã JWT token"
	},
	"ef-service snippet": {
		"prefix": "ef-service",
		"body": [
			"var connectionString = builder.Configuration.GetConnectionString(\"${1:DefaultConnection}\");",
			"builder.Services.AddDbContext<${2:TContext}>(options =>",
			"    options.UseSqlServer(connectionString));"
		],
		"description": "Add Entity Framework DbContext with SQL Server"
	},
	"EF Core Stored Procedure with Parameters": {
		"prefix": "ef-stored-procedure",
		"body": [
			"// Define parameters",
			"SqlParameter[] parameters = new SqlParameter[]",
			"{",
			"    new SqlParameter(\"@param1\", value1),",
			"    new SqlParameter(\"@param2\", value2),",
			"    // Add more parameters as needed",
			"};",
			"",
			"// Construct SQL query",
			"string sql = \"EXEC ProcedureName @param1, @param2\"; // Match your parameter names",
			"",
			"// Execute stored procedure and map to model",
			"var result = await _context.Database",
			"    .SqlQueryRaw<YourModel>(sql, parameters)",
			"    .ToListAsync();"
		],
		"description": "Call a stored procedure using EF Core with parameters"
	},
	"Query with SqlParameter and SqlQueryRaw": {
		"prefix": "ef-sql-query-raw",
		"body": [
			"// Tạo tham số truy vấn",
			"SqlParameter param1 = new SqlParameter(\"@param1\", $1);",
			"var result = await _context.Database.SqlQueryRaw<${2:ModelType}>(",
			"    $@\"SELECT * FROM TableName WHERE Column = @param1\",",
			"    param1).ToListAsync();"
		],
		"description": "Truy vấn có SqlParameter và SqlQueryRaw"
	},
	"EF Core ExecuteSqlRaw Insert": {
		"prefix": "ef-sqlexecute-insert",
		"body": [
			"string sql = \"INSERT INTO Tablename (Column1, Column2) VALUES (@param1, @param2)\";",
			"SqlParameter[] parameters = {",
			"    new SqlParameter(\"@param1\", value1),",
			"    new SqlParameter(\"@param2\", value2)",
			"};",
			"",
			"int affectedRows = await _context.Database.ExecuteSqlRawAsync(sql, parameters);"
		],
		"description": "ExecuteSqlRaw INSERT template"
	},
	"EF Core ExecuteSqlRaw Update": {
		"prefix": "ef-sqlexecute-update",
		"body": [
			"string sql = \"UPDATE Tablename SET Column1 = @param1 WHERE ColumnId = @paramId\";",
			"SqlParameter[] parameters = {",
			"    new SqlParameter(\"@param1\", value1),",
			"    new SqlParameter(\"@paramId\", valueId)",
			"};",
			"",
			"int affectedRows = await _context.Database.ExecuteSqlRawAsync(sql, parameters);"
		],
		"description": "ExecuteSqlRaw UPDATE template"
	},
	"EF Core ExecuteSqlRaw Delete": {
		"prefix": "ef-sqlexecute-delete",
		"body": [
			"string sql = \"DELETE FROM Tablename WHERE ColumnId = @paramId\";",
			"SqlParameter[] parameters = {",
			"    new SqlParameter(\"@paramId\", valueId)",
			"};",
			"",
			"int affectedRows = await _context.Database.ExecuteSqlRawAsync(sql, parameters);"
		],
		"description": "ExecuteSqlRaw DELETE template"
	}
}